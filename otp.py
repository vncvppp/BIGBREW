
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer

from pathlib import Path
from tkinter import Tk, Canvas, Entry, Button, PhotoImage, messagebox
import time
import sys
import os

OUTPUT_PATH = Path(__file__).parent

def resource_path(relative_path):
    """Get absolute path to resource, works for dev and for PyInstaller"""
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    
    return os.path.join(base_path, relative_path)

def relative_to_assets(path: str) -> Path:
    return Path(resource_path(f"resources/otp/{path}"))


class OTPVerificationWindow:
    def __init__(self, parent, user_data, otp_code, verification_callback, back_callback, get_db_connection, purpose='signup'):
        self.parent = parent
        self.user_data = user_data
        self.otp_code = otp_code
        self.verification_callback = verification_callback
        self.back_callback = back_callback
        self.get_db_connection = get_db_connection
        self.purpose = purpose  # 'signup' or 'password_reset'
        self.otp_entries = []
        self.otp_expiry_time = time.time() + 180  # 3 minutes
        self._is_destroyed = False  # Track if window is destroyed
        self._timer_id = None  # Track the timer
        
        # Store references to all widgets we create
        self.widgets = []
        
        self.setup_ui()
        self.start_otp_timer()
        
    def setup_ui(self):
        self.canvas = Canvas(
            self.parent,
            bg="#FFFFFF",
            height=440,
            width=800,
            bd=0,
            highlightthickness=0,
            relief="ridge"
        )
        self.canvas.place(x=0, y=0)
        self.widgets.append(self.canvas)
        
        # Background image
        self.image_image_1 = PhotoImage(file=relative_to_assets("image_1.png"))
        self.canvas.create_image(400.0, 220.0, image=self.image_image_1)
        
        # Header rectangle
        self.canvas.create_rectangle(
            110.0, 124.0, 247.0, 140.0,
            fill="#3A280F", outline=""
        )
        
        # Title rectangle
        self.canvas.create_rectangle(
            91.0, 84.0, 254.0, 132.0,
            fill="#3A280F", outline=""
        )
        
        # Title text
        title_text = "Email Verification" if self.purpose == 'signup' else "Password Reset Verification"
        self.canvas.create_text(
            46.0, 85.0, anchor="nw",
            text=title_text,
            fill="#FFFFFF", font=("Inter Bold", 32 * -1)
        )
        
        # Title text
        instruction_text = "Enter the 6-digit verification code sent to your email:" if self.purpose == 'signup' else "Enter the 6-digit verification code sent to your email for password reset:"
        self.canvas.create_text(
            91.0, 140.0, anchor="nw",
            text=instruction_text,
            fill="#FFFFFF", font=("Inter Bold", 13 * -1)
        )
        
        # OTP container rectangle
        self.canvas.create_rectangle(
            25.0, 171.0, 316.0, 260.0,
            fill="#3A280F", outline=""
        )

        # Verify button
        self.button_image_1 = PhotoImage(file=relative_to_assets("button_verify.png"))
        self.button_verify = Button(
            image=self.button_image_1,
            borderwidth=0,
            highlightthickness=0,
            command=self.verify_otp,
            relief="flat"
        )
        self.button_verify.place(x=54.0, y=323.0, width=245.0, height=42.0)
        self.widgets.append(self.button_verify)

        # Resend OTP button
        self.button_image_2 = PhotoImage(file=relative_to_assets("button_resend.png"))
        self.buttonLbl_resendotp = Button(
            image=self.button_image_2,
            borderwidth=0,
            highlightthickness=0,
            command=self.resend_otp,
            relief="flat",
            state='disabled'  # Initially disabled
        )
        self.buttonLbl_resendotp.place(x=66.0, y=376.0, width=224.0, height=26.0)
        self.widgets.append(self.buttonLbl_resendotp)

        # Back button - create after all other elements
        try:
            button_back_1 = PhotoImage(
                file=relative_to_assets("button_back.png"))
            button_back = Button(
                image=button_back_1,
                borderwidth=0,
                highlightthickness=0,
                command=self.go_back,
                relief="flat",
                cursor="hand2"
            )
            button_back.place(
                x=10.0,
                y=10.0,
                width=30.0,
                height=30.0
            )
            # Ensure back button is on top of all other elements
            button_back.lift()
            self.widgets.append(button_back)
            # Store reference to prevent garbage collection
            self.button_back_image = button_back_1
        except Exception as e:
            print(f"Error loading back button image: {e}")
            # Fallback: create text button if image fails
            button_back = Button(
                text="â†",
                borderwidth=0,
                highlightthickness=0,
                command=self.go_back,
                relief="flat",
                cursor="hand2",
                bg="#3A280F",
                fg="#FFFFFF",
                font=("Arial", 12, "bold")
            )
            button_back.place(
                x=10.0,
                y=10.0,
                width=30.0,
                height=30.0
            )
            button_back.lift()
            self.widgets.append(button_back)

        # OTP entry fields
        self.setup_otp_entries()

        # Set tab order for proper navigation
        self.setup_tab_order()

    def setup_tab_order(self):
        """Setup proper tab navigation order"""
        # Set tab order: OTP1 -> OTP2 -> OTP3 -> OTP4 -> OTP5 -> OTP6 -> Verify Button -> Resend Button
        if len(self.otp_entries) >= 6:
            for i in range(5):  # Link OTP1 to OTP5 to their next fields
                self.otp_entries[i].bind('<Tab>', lambda e, idx=i: self.focus_next_otp(e, idx))
                self.otp_entries[i].bind('<Shift-Tab>', lambda e, idx=i: self.focus_prev_otp(e, idx))
            
            # OTP6 should tab to Verify button
            self.otp_entries[5].bind('<Tab>', lambda e: self.focus_verify_button(e))
            self.otp_entries[5].bind('<Shift-Tab>', lambda e, idx=4: self.focus_prev_otp(e, idx))
            
            # Verify button tab order
            self.button_verify.bind('<Tab>', self.focus_resend_button)
            self.button_verify.bind('<Shift-Tab>', lambda e: self.focus_prev_from_verify(e))
            
            # Resend button tab order - cycle back to first OTP
            self.buttonLbl_resendotp.bind('<Tab>', lambda e: self.focus_first_otp(e))
            self.buttonLbl_resendotp.bind('<Shift-Tab>', lambda e: self.focus_verify_button(e))
        
        # Also handle Enter key for quick submission
        for entry in self.otp_entries:
            entry.bind('<Return>', lambda e: self.verify_otp())
        
        self.button_verify.bind('<Return>', lambda e: self.verify_otp())

    def focus_next_otp(self, event, current_index):
        """Focus on next OTP field when Tab is pressed"""
        if current_index < len(self.otp_entries) - 1:
            self.otp_entries[current_index + 1].focus()
        return "break"  # Prevent default tab behavior

    def focus_prev_otp(self, event, current_index):
        """Focus on previous OTP field when Shift+Tab is pressed"""
        if current_index > 0:
            self.otp_entries[current_index - 1].focus()
        return "break"  # Prevent default tab behavior

    def focus_verify_button(self, event):
        """Focus on verify button"""
        self.button_verify.focus()
        return "break"

    def focus_resend_button(self, event):
        """Focus on resend button"""
        self.buttonLbl_resendotp.focus()
        return "break"


    def focus_prev_from_verify(self, event):
        """Focus on last OTP field from verify button"""
        if self.otp_entries:
            self.otp_entries[-1].focus()
        return "break"

    def focus_first_otp(self, event):
        """Focus on first OTP field"""
        if self.otp_entries:
            self.otp_entries[0].focus()
        return "break"

    def setup_otp_entries(self):
        """Setup the 6 OTP entry fields with proper alignment"""
        # Entry positions and images based on new layout
        entry_data = [
            (66.0, 240.0, "entry_otp1.png"),   # OTP1
            (111.0, 240.0, "entry_otp2.png"),  # OTP2
            (156.0, 240.0, "entry_otp3.png"),  # OTP3
            (201.0, 240.0, "entry_otp4.png"),  # OTP4
            (246.0, 240.0, "entry_otp5.png"),  # OTP5
            (291.0, 240.0, "entry_otp6.png")   # OTP6
        ]
        
        vcmd = (self.parent.register(self.validate_numeric), '%P')
        
        for i, (x, y, image_name) in enumerate(entry_data):
            # Create the background image first
            entry_image = PhotoImage(file=relative_to_assets(image_name))
            self.canvas.create_image(x, y, image=entry_image)
            
            # Store the image reference to prevent garbage collection
            setattr(self, f"entry_image_{i}", entry_image)
            
            # Create the entry widget with exact positioning
            entry = Entry(
                bd=0, 
                bg="#FFF8E7", 
                fg="#000716", 
                highlightthickness=0,
                font=("Inter Bold", 16), 
                justify='center', 
                width=2,
                relief="flat",
                validate='key',
                validatecommand=vcmd
            )
            
            # Calculate precise positioning based on new layout
            entry_width = 24
            entry_height = 38
            entry_x = x - (entry_width / 2)
            entry_y = y - (entry_height / 2)
            
            entry.place(x=entry_x, y=entry_y, width=entry_width, height=entry_height)
            
            # Bind events for navigation
            entry.bind('<KeyRelease>', lambda e, idx=i: self.on_otp_keyrelease(e, idx))
            entry.bind('<FocusIn>', lambda e, entry=entry: self.on_otp_focusin(entry))
            
            self.otp_entries.append(entry)
            self.widgets.append(entry)

        # Focus on first OTP entry when window loads
        if self.otp_entries:
            self.parent.after(100, lambda: self.otp_entries[0].focus())
            
    def validate_numeric(self, new_value):
        """Validate that the entry contains only numeric input"""
        if new_value == "":
            return True
        return new_value.isdigit()

    def on_otp_keyrelease(self, event, current_index):
        """Handle OTP entry navigation"""
        entry = self.otp_entries[current_index]
        
        if event.keysym in ('BackSpace', 'Delete'):
            if current_index > 0 and not entry.get():
                self.otp_entries[current_index - 1].focus()
            return
        
        if entry.get() and len(entry.get()) == 1:
            if current_index < len(self.otp_entries) - 1:
                self.otp_entries[current_index + 1].focus()
            else:
                # Last OTP field filled, auto-focus verify button
                self.button_verify.focus()

    def on_otp_focusin(self, entry):
        """Select all text when focusing on OTP entry"""
        entry.select_range(0, 'end')

    def get_entered_otp(self):
        """Get the complete OTP from all entry fields"""
        return ''.join(entry.get() for entry in self.otp_entries)

    def verify_otp(self):
        """Verify the entered OTP against database"""
        entered_otp = self.get_entered_otp()
        
        if time.time() > self.otp_expiry_time:
            messagebox.showerror("Error", "OTP has expired. Please request a new one.")
            return
        
        if len(entered_otp) != 6:
            messagebox.showerror("Error", "Please enter the complete 6-digit OTP")
            # Focus on first empty OTP field
            for i, entry in enumerate(self.otp_entries):
                if not entry.get():
                    entry.focus()
                    break
            return
        
        # Verify OTP against database
        db_connection = self.get_db_connection()
        if not db_connection:
            messagebox.showerror("Database Error", "Cannot connect to database")
            return
            
        try:
            cursor = db_connection.cursor(dictionary=True)
            cursor.execute("""
                SELECT * FROM otp_verification 
                WHERE email = %s AND otp_code = %s AND purpose = %s 
                AND expires_at > NOW() AND is_used = FALSE
            """, (self.user_data['email'], entered_otp, self.purpose))
            
            otp_record = cursor.fetchone()
            
            if otp_record:
                # Mark OTP as used
                cursor.execute("""
                    UPDATE otp_verification 
                    SET is_used = TRUE, attempts = attempts + 1 
                    WHERE otp_id = %s
                """, (otp_record['otp_id'],))
                db_connection.commit()
                
                messagebox.showinfo("Success", "OTP verified successfully!")
                self.verification_callback()
            else:
                # Check if OTP exists but is expired or used
                cursor.execute("""
                    SELECT * FROM otp_verification 
                    WHERE email = %s AND otp_code = %s AND purpose = %s
                """, (self.user_data['email'], entered_otp, self.purpose))
                
                existing_otp = cursor.fetchone()
                if existing_otp:
                    if existing_otp['is_used']:
                        messagebox.showerror("Error", "This OTP has already been used. Please request a new one.")
                    else:
                        messagebox.showerror("Error", "OTP has expired. Please request a new one.")
                else:
                    messagebox.showerror("Error", "Invalid OTP. Please try again.")
                
                # Clear all fields and focus on first one
                for entry in self.otp_entries:
                    entry.delete(0, 'end')
                if self.otp_entries:
                    self.otp_entries[0].focus()
                    
        except Exception as e:
            messagebox.showerror("Error", f"Verification failed: {str(e)}")
        finally:
            if db_connection and db_connection.is_connected():
                cursor.close()

    def resend_otp(self):
        """Resend OTP code"""
        from utils import UtilityFunctions, EmailService
        from datetime import datetime, timedelta
        
        self.otp_code = UtilityFunctions.generate_otp()
        self.otp_expiry_time = time.time() + 180  # Reset to 3 minutes
        
        # Store new OTP in database
        db_connection = self.get_db_connection()
        if db_connection:
            try:
                cursor = db_connection.cursor()
                expires_at = datetime.now() + timedelta(minutes=3)
                cursor.execute("""
                    INSERT INTO otp_verification (email, otp_code, purpose, expires_at)
                    VALUES (%s, %s, %s, %s)
                """, (self.user_data['email'], self.otp_code, 'signup', expires_at))
                db_connection.commit()
                cursor.close()
            except Exception as e:
                print(f"Error storing OTP in database: {e}")
        
        # Clear OTP entries
        for entry in self.otp_entries:
            entry.delete(0, 'end')
        
        # Resend email
        email_service = EmailService()
        if email_service.send_otp_email(self.user_data['email'], self.otp_code):
            messagebox.showinfo("Success", "New OTP sent to your email!")
            if self.otp_entries:
                self.otp_entries[0].focus()
            
            # Reset timer and disable resend button
            self.buttonLbl_resendotp.config(state='disabled')
            self.start_otp_timer()
        else:
            messagebox.showerror("Error", "Failed to send OTP. Please try again.")

    def start_otp_timer(self):
        """Start timer to check OTP expiry"""
        # Cancel any existing timer
        if self._timer_id:
            self.parent.after_cancel(self._timer_id)
        self._timer_id = self.parent.after(1000, self.check_otp_expiry)

    def check_otp_expiry(self):
        """Check if OTP has expired"""
        # Check if window is destroyed before accessing widgets
        if self._is_destroyed:
            return
            
        remaining_time = self.otp_expiry_time - time.time()
        if remaining_time <= 0:
            # Enable resend button only if window still exists and widget exists
            if (not self._is_destroyed and 
                hasattr(self, 'buttonLbl_resendotp') and 
                self.buttonLbl_resendotp.winfo_exists()):
                self.buttonLbl_resendotp.config(state='normal')
        else:
            # Schedule next check only if window still exists
            if not self._is_destroyed:
                self._timer_id = self.parent.after(1000, self.check_otp_expiry)

    def go_back(self):
        """Go back to previous screen - called programmatically"""
        self.destroy()
        self.back_callback()

    def destroy(self):
        """Clean up only the OTP window widgets"""
        # Mark as destroyed to prevent timer callbacks
        self._is_destroyed = True
        
        # Cancel any pending timers
        if self._timer_id:
            try:
                self.parent.after_cancel(self._timer_id)
            except:
                pass  # Timer might already be cancelled
        
        # Destroy only the widgets we created, not all widgets in parent
        for widget in self.widgets:
            try:
                if widget.winfo_exists():
                    widget.destroy()
            except:
                pass  # Widget might already be destroyed
